---
title:  "JVM中的Stack和Heap"
date: 2021-05-31 00:00:00
description: "JVM裡的Stack與Heap介紹"
tags: ["java","jvm"]
categories: java
---

## Introduction

在使用 java 開發時，常常都會看到 `stack` 與 `heap` 這兩個詞，Stack 繁中為 **堆疊** 、簡中為 **棧**，Heap 繁中為 **堆積** 、簡中為 **堆**，他們兩個都是JVM記憶體管理的一部份。

java 檔經過編譯後會產生Class檔案（bytecode），只能在 JVM 上運行，JVM運行時也需要記憶體儲存運算所需的資料、指令，JVM 裡有需多的記憶體，但其中 Stack 與 Heap 最常被比較，底下就來介紹這兩者是什麼。

## JAVA中的資料型態

在介紹 Stack 與 Heap 之前，首先要先介紹的是 java 的資料型態。在 java 裡面，不是每個東西都是抽象化為物件，可將 java 區分為兩種型態系統，分別如下

* 基本型態（Primitive Type）
* 類別型態（Class type），或叫參考型態（Reference type）

### 基本型態

基本型態得考慮資料用多少記憶體長度來存比較經濟，利用程式語法告訴 JVM，然後由 JVM 自動在記憶體中配置與管理，主要可區分為整數、位元組、浮點數、字元與布林，介紹如下：

* 整數

  整數又可細分為 `short` 整數（2個位元組）、`int` 整數（4個位元組）、`long` 整數（8個位元組），`long` 整數範圍比 `int` 整數大，`int` 整數範圍又比 `short` 整數大。

* 位元組

  `byte` 型態的長度就是一個位元組，在需要逐位元處理資料時（ex. 影像、編碼處理），就會使用 `byte` 型態，如果是用於整數，可表示 -128 ~ 127的整數。

* 浮點數

  用來儲存小數數值，又可細分為 `float` 浮點數（4個位元組）、`double` 浮點數（8個位元組），其中 `double` 浮點數需要的記憶體空間比 `float` 浮點數大，精確度也比較大。

* 字元

  `char` 型態用來儲存字元符號，每個字元為兩個位元組，中英文字元皆一樣。

* 布林

  `boolean` 型態可表示 *true* 與 *false*，在 Java 中不用在意 `boolean` 型態的長度，也無法將`boolean`型態與其它型態作運算。

**總結**

* 共有八種基本型態：**short**、**int**、**long**、**byte**、**float**、**double**、**char**、**boolean**

* 宣告基本型態的方式如下

  ```java
  int a = 3;
  long b = 234L;
  boolean c = true;
  ...
  ```

* 長度與生命週期皆可知（程式碼區塊執行完即扔掉）

* 運算速度快，但長度與內容受限。

### 類別型態（參考型態）

* 大多屬於此類，例如 **Integer**、**String**、**Long** 等等，或者自訂的類別

* 通常需使用語法 `new` 創建，使用方法如下

  ```java
  User user = new User("Mark");
  ```

* 因為是在執行時才動態創建，所以長度及生命週期都不可預知

* 靈活但運算較耗時

## Stack

每一個 Thread 都有自己的 Stack，Thread 之間的 Stack 相互獨立，程式中的 `local primitive variables`、`local object reference variables` 都會被儲存在 Stack。

Stack 是一種後進先出（LIFO，Last-in-First-out）的容器，其存取速度快且管理簡單。由於 Java 中的變數跟函式皆是後進先出，越晚產生的越先被回收、銷毀，所以 Stack 很適合作為**區域變數**、**函式參數**與**函式返回位址**的儲存容器。

因為 Stack 中的資料生命週期都是規律的，可由系統自行產生、回收，我們不需介入。

### Example

```java
public void Method1()
{
  int i = 1;
}

public void Method2()
{
  Method1();
}
```

在 Method1 裡面的 `int i = 1`，這個變數 `i` 會存放在 stack 內，他只會在執行Method1時才會用到，生命週期是可以預測的。

而 Method1 只有在執行 Method2 時才能用到，所以它包含的變數也存放在stack。

## Heap

Process 的 Memory Space 是專門儲存共享資料 / 資源的，而 Heap 就屬於這種共享資料。

當類別型態（Class Type）在創建instance時（ex. `new User("Mark")`），此資料就會放在 Heap 中，系統會在 Heap 中找一個地方放置此 User instance的 屬性資料。因為 Heap 存放的是共享資料，所以不管這個instance是由哪個 Thread 所創建的，只要是同一個 Process裡的不同 Thread 都可以存取。

由於 instance 的生命週期不可預知，系統較難自行回收，所以在 java 內有 Garbage Collection（GC）可以自動去清理 Heap 內已經沒有被參考（Reference）的資料

### Example

* 範例一

  ```java
  public static void main(String... args)
  {
    User user1 = new User("Mark");
  }
  ```

  `User` 物件會儲存在heap，但它的reference variable `user1` 會儲存在Stack。

* 範例二

  ```java
  int a = 123;
  long b = 456L;
  User c = new User("Mark", Gender.MALE);
  ```

  1. 前兩行指令都是 `Primitive type`，會在 Stack 內建立變數 `a`、`b`，並將 value `123`、``456L` 儲存在變數內。

  2. 第三行指令要切成等號左邊跟右邊，首先先看右邊的部分，instance `User` 有兩個參數，分別是`name` 與 `gender`，此時 Heap 的一個位址（ex. `0x1111`）會拿來存放 instance 的屬性資料（ex. `name`、`gender`...）
  3. 再來看第三行指令左邊的部分，instance 的記憶體位址（`0x1111`）會指定給變數 `c` 參考，其中 `c` 是reference variable，他會儲存在 Stack。

  ※ 第三行指令簡單來說可以這樣看

  1. 創建 User instance（name = Mark, gender = Male）並儲存在 Heap，最後回傳記憶體位址
  2. 在 Stack 新增變量 `c`，並將記憶體位址傳給 `c` 參考

## On-heap and Off-heap

如前面所說，類別型態（Class Type）在創建instance時（ex. `new User("Mark")`），此資料就會放在 Heap 中。一般情況下，java 中所分配的非空物件都會由 JVM 的 GC 來處理，這種 Heap 又被稱為 **on-heap memory**，JVM 會對這種垃圾記憶體回收，在某些特定時間點，還會進行一次徹底的回收（full gc）。執行 full gc 時，還會對所有的 on-heap memory 進行完整的掃描，所以一次 full gc 會對應用程式的效能影響，會與 on-heap memory 的大小成正比，越大的 on-heap memory 越會影響應用程式的效能。

為了解決這個問題，有另一種方式是使用 **off-heap memory**。off-heap memory 意味著將 memory 分配給 JVM 的 Heap 以外的記憶體，這些記憶體不受 JVM管理，而是直接受到作業系統管理，這樣就能保持一個較小的 heap，進而降低 full gc 進行時的效能影響。

off-heap memory 與 memory pool 一樣，皆可縮短 GC 的時間，但他適用的物件和 memory pool相反，memory pool 適用於生命週期較短的可變物件，而 off-heap memory 則是適用生命週期中等或較長的物件。off-heap memory具有以下特點

- 對於大記憶體有良好的伸縮性
- 改善 GC 造成的效能降低
- 在程序間可以共享，減少虛擬機器間的複製

不過 off-heap memory 也有其他問題，例如資料結構變得不直觀，若資料結構比較複雜，還需要對它序列化（serialization），序列化也會影響效能，且因為可使用更大的記憶體，所以也需要注意硬體的速度對它的影響。

## 結論

1. Heap 是 Class Type 創建實例時存放資料的地方，在 Heap 創建完成後會回傳所在的記憶體位址。
2. 變數可能是 Primitive Type 或 Class Type 。若是 Primitive Type，則在 Stack 內的變數值為實際值；若是 Class Type，實例資料會儲存在 Heap 中，Stack 內的變數值為實例在 Heap 中的記憶體位址。

## Reference

* [Java 面試 - JVM 的 Stack 和 Heap](https://blog.marklee.tw/java-interview-jvm-stack-heap/#:~:text=Java%20%E7%9A%84%E8%B3%87%E6%96%99%E9%A1%9E%E5%9E%8B%E5%88%86,%E6%89%80%E5%9C%A8%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E4%BD%8D%E5%9D%80%E3%80%82)
* [基礎語言 -資料類別](https://travis90736.pixnet.net/blog/post/106172000)
* [Java - Stack 與 Heap 的分別](https://ithelp.ithome.com.tw/articles/10229672?sc=pt)
* [型態](https://openhome.cc/Gossip/Java/Type.html)
* [Difference between "on-heap" and "off-heap"](https://stackoverflow.com/questions/6091615/difference-between-on-heap-and-off-heap)
* [堆外記憶體(off-heap)、堆內記憶體(on-heap)](https://www.itread01.com/content/1550230763.html)